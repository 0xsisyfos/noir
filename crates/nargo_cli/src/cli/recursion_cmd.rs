use std::{path::{PathBuf, Path}, collections::BTreeMap};

use crate::{
    errors::CliError,
    constants::{PROOFS_DIR, TARGET_DIR, VERIFIER_INPUT_FILE, PROOF_EXT}
};

use clap::Args;
use nargo::ops::{proof_as_fields, vk_as_fields};
use noirc_abi::input_parser::{Format, InputValue};
use super::{NargoConfig, fs::{program::read_program_from_file, inputs::{read_inputs_from_file, write_inputs_to_file}, load_hex_data, create_named_dir}, compile_cmd::compile_circuit};

#[derive(Debug, Clone, Args)]
pub(crate) struct RecursionCommand {
    /// The name of the proof
    proof_name: String,

    /// The name of the circuit build fiels (ACIR, proving and verification key)
    circuit_name: String,
}

pub(crate) fn run(args: RecursionCommand, config: NargoConfig) -> Result<(), CliError> {
    let proof_path = config.program_dir.join(PROOFS_DIR).join(&args.proof_name).with_extension(PROOF_EXT);

    let target_dir = config.program_dir.join(TARGET_DIR);

    let circuit_build_path = target_dir.join(&args.circuit_name);

    let recursion_artifacts_path = target_dir.join("recursion");
    create_named_dir(recursion_artifacts_path.as_ref(), "recursion");

    gen_recursion_artifacts_with_path(config.program_dir, proof_path, circuit_build_path, recursion_artifacts_path, args.circuit_name)?;

    Ok(())
}

pub(crate) fn gen_recursion_artifacts_with_path<P: AsRef<Path>>(
    program_dir: P,
    proof_path: PathBuf,
    circuit_build_path: P,
    recursion_artifacts_path: P,
    circuit_name: String,
) -> Result<(), CliError> {
    // TODO: do we want circuit's to be optional? If the circuit has not changed
    // the verification key will be the same, but the proof generated could potentially be generated by a different circuit
    // let preprocessed_program = match circuit_build_path {
    //     Some(circuit_build_path) => read_program_from_file(circuit_build_path)?,
    //     None => {
    //         let compiled_program =
    //             compile_circuit(&backend, program_dir.as_ref(), compile_options)?;
    //         preprocess_program(&backend, compiled_program)?
    //     }
    // };

    let preprocessed_program = read_program_from_file(&circuit_build_path)?;

    let backend = crate::backends::ConcreteBackend::default();

    let public_abi = preprocessed_program.abi.clone().public_abi();
    let (public_inputs_map, return_value) =
        read_inputs_from_file(program_dir, VERIFIER_INPUT_FILE, Format::Toml, &public_abi)?;
    let public_inputs = public_abi.encode(&public_inputs_map, return_value)?;

    let proof = &load_hex_data(&proof_path)?;

    let proof_fields = proof_as_fields(&backend, proof, public_inputs)?;
    
    let mut recursion_artifacts_map = BTreeMap::new();
    recursion_artifacts_map.insert("proof".to_owned(), InputValue::Vec(proof_fields));

    let (vk_fields, vk_hash) = vk_as_fields(&backend, &preprocessed_program.verification_key)?;
    recursion_artifacts_map.insert("verification_key".to_owned(), InputValue::Vec(vk_fields));
    recursion_artifacts_map.insert("key_hash".to_owned(), InputValue::Field(vk_hash));

    write_inputs_to_file(&recursion_artifacts_map, &None, recursion_artifacts_path, &circuit_name, Format::Toml)?;

    Ok(())
}
