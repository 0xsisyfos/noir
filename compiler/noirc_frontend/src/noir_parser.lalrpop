use std::str::FromStr;

use acvm::FieldElement;
use noirc_errors::{Position, Span};

use crate::lexer::token::{Keyword, Tok};
use crate::lexer::token as noir_token;
use crate::lexer::lexer::IntType;
use crate::lexer::errors::LexerErrorKind;
use crate::ParsedModule;
use crate::parser::TopLevelStatement;
use crate::{Ident, Path, PathKind, UseTree, UseTreeKind};

use lalrpop_util::{ErrorRecovery, ParseError};

// TODO: is this what we want for ErrorRecovery?
// grammar<'err>(errors: &'err mut Vec<LexerErrorKind>);
// grammar;
// grammar<'input>(input: &'input str);
// grammar<'input>(input: &'input str);
grammar<'input, 'err>(input: &'input str, errors: &'err mut Vec<ErrorRecovery<usize, Tok<'input>, &'static str>>);

extern {
    type Location = usize;

    // TODO: wip error recovery
    // type Error = Vec<LexerErrorKind>;
    // type Error = LexerErrorKind;
    type Error = LexerErrorKind;

    // NOTE: each token needs a terminal defined
    enum Tok<'input> {
        // Str => Tok::Str(<String>),
        str => Tok::Str(<&'input str>),
        ident => Tok::Ident(<&'input str>),

        // symbols
        "<" => Tok::Less,
        "<=" => Tok::LessEqual,
        ">" => Tok::Greater,
        ">=" => Tok::GreaterEqual,
        "==" => Tok::Equal,
        "!=" => Tok::NotEqual,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Star,
        "/" => Tok::Slash,
        "%" => Tok::Percent,
        "&" => Tok::Ampersand,
        "^" => Tok::Caret,
        "<<" => Tok::ShiftLeft,
        ">>" => Tok::ShiftRight,
        "." => Tok::Dot,
        ".." => Tok::DoubleDot,
        "(" => Tok::LeftParen,
        ")" => Tok::RightParen,
        "{" => Tok::LeftBrace,
        "}" => Tok::RightBrace,
        "[" => Tok::LeftBracket,
        "]" => Tok::RightBracket,
        "->" => Tok::Arrow,
        "|" => Tok::Pipe,
        "#" => Tok::Pound,
        "," => Tok::Comma,
        ":" => Tok::Colon,
        "::" => Tok::DoubleColon,
        ";" => Tok::Semicolon,
        "!" => Tok::Bang,
        "=" => Tok::Assign,
        // keywords
        "as" => Tok::Keyword(Keyword::As),
        "assert" => Tok::Keyword(Keyword::Assert),
        "assert_eq" => Tok::Keyword(Keyword::AssertEq),
        "bool" => Tok::Keyword(Keyword::Bool),
        "break" => Tok::Keyword(Keyword::Break),
        "call_data" => Tok::Keyword(Keyword::CallData),
        "char" => Tok::Keyword(Keyword::Char),
        "comptime" => Tok::Keyword(Keyword::CompTime),
        "constrain" => Tok::Keyword(Keyword::Constrain),
        "continue" => Tok::Keyword(Keyword::Continue),
        "contract" => Tok::Keyword(Keyword::Contract),
        "crate" => Tok::Keyword(Keyword::Crate),
        "dep" => Tok::Keyword(Keyword::Dep),
        "distinct" => Tok::Keyword(Keyword::Distinct),
        "else" => Tok::Keyword(Keyword::Else),
        "Field" => Tok::Keyword(Keyword::Field),
        "fn" => Tok::Keyword(Keyword::Fn),
        "for" => Tok::Keyword(Keyword::For),
        "fmtstr" => Tok::Keyword(Keyword::FormatString),
        "global" => Tok::Keyword(Keyword::Global),
        "if" => Tok::Keyword(Keyword::If),
        "impl" => Tok::Keyword(Keyword::Impl),
        "in" => Tok::Keyword(Keyword::In),
        "let" => Tok::Keyword(Keyword::Let),
        "mod" => Tok::Keyword(Keyword::Mod),
        "mut" => Tok::Keyword(Keyword::Mut),
        "pub" => Tok::Keyword(Keyword::Pub),
        "quote" => Tok::Keyword(Keyword::Quote),
        "return" => Tok::Keyword(Keyword::Return),
        "return_data" => Tok::Keyword(Keyword::ReturnData),
        "str" => Tok::Keyword(Keyword::String),
        "struct" => Tok::Keyword(Keyword::Struct),
        "trait" => Tok::Keyword(Keyword::Trait),
        "type" => Tok::Keyword(Keyword::Type),
        "unchecked" => Tok::Keyword(Keyword::Unchecked),
        "unconstrained" => Tok::Keyword(Keyword::Unconstrained),
        "use" => Tok::Keyword(Keyword::Use),
        "where" => Tok::Keyword(Keyword::Where),
        "while" => Tok::Keyword(Keyword::While),
        // bool
        "true" => Tok::Bool(true),
        "false" => Tok::Bool(false),
        // whitespace
        " " => Tok::Whitespace(" "),
        "\n" => Tok::Whitespace("\n"),
        "\r" => Tok::Whitespace("\r"),
        "\t" => Tok::Whitespace("\t"),
        whitespace => Tok::Whitespace(_),

        EOF => Tok::EOF,
    }
}


pub Term: Tok<'input> = {
    <b:Bool> EOF => b,

    // EOF => Tok::EOF,

}


// pub Program: &'input ParsedModule = {
//     // <m:Module> EOF => m,
//     // EOF => (),

//     // <x:TopLevelStatement> "\n" <p:Program> => x, // TODO

//     EOF => ParsedModule::default(),
// }

TopLevelStatement: TopLevelStatement = {

    // use statement from BNF grammar
    // use_statement ::= "use" WHITESPACE path (WHITESPACE "as" ident)? ";"

    // TODO: does this allow zero-size whitespace?
    "use" whitespace <mut prefix:Path> <alias:Alias?> => {

        let ident = prefix.pop();
        let kind = UseTreeKind::Path(ident, alias);
        TopLevelStatement::Import(UseTree { prefix, kind })
    }
}

Alias: Ident = {
    whitespace "as" <Ident> => <>,
}

pub Path: Path = {
    <lo:@L> <opt_crate:"crate"?> <opt_dep:"dep"?> "::" <i:Ident> <mut segments:("::" <Ident>)*> ";" <hi:@R> => {
        segments.insert(0, i);
        let mut kind = PathKind::Plain;
        match (opt_crate, opt_dep) {
            (None, None) => (),
            (Some(_), None) => kind = PathKind::Crate,
            (None, Some(_)) => kind = PathKind::Dep,
            (Some(_), Some(_)) => {
                let token = noir_token::Token::Ident("cratedep".to_string());
                let span = Span::from(lo as u32..(lo + "cratedep".len()) as u32);
                segments.insert(0, Ident::from_token(token, span))
            },
        }
        let span = Span::from(lo as u32..hi as u32);
        Path { segments, kind, span }
    },
}

Ident: Ident = {
    <lo:@L> <i:ident> <hi:@R> => {
        let token = noir_token::Token::Ident(i.to_string());
        let span = Span::from(lo as u32..hi as u32);
        Ident::from_token(token, span)
    },
}

Bool: Tok<'input> = {
    "true" => Tok::Bool(true),
    "false" => Tok::Bool(false),
};





// pub Term: Tok = {
//     <b:Bool> EOF => b,
//     EOF => Tok::EOF,
//     // <n:Num> => Tok::Int(n),
//     // "(" <t:Term> ")" => t,
// };



// Num: FieldElement = <integer_str_raw:r"[0-9]+"> =>? {
//     // Underscores needs to be stripped out before the literal can be converted to a `FieldElement.
//     let integer_str = integer_str_raw.replace('_', "");

//     match FieldElement::try_from_str(&integer_str) {
//         None => {
//             let error = vec![LexerErrorKind::InvalidIntegerLiteral {
//                 // TODO: fix span?
//                 span: Span::empty(0), // inclusive(start, end),
//                 found: integer_str,
//             }];

//             // TODO: error recovery
//             // errors.push(ParseError::User { error });
//             Err(ParseError::User { error })

//         }
//         Some(integer) => Ok(integer),
//     }
// };

