use std::str::FromStr;

use acvm::FieldElement;
use noirc_errors::{Position, Span};

// use crate::lexer::token as noir_token;
use crate::lexer::token::Token;
use crate::lexer::lexer::IntType;
use crate::lexer::errors::LexerErrorKind;

use lalrpop_util::{ErrorRecovery, ParseError};

// TODO: is this what we want for ErrorRecovery?
// grammar<'err>(errors: &'err mut Vec<LexerErrorKind>);
grammar;

extern {
    type Location = usize;

    // TODO: wip error recovery
    // type Error = Vec<LexerErrorKind>;
    type Error = LexerErrorKind;

    // NOTE: each token needs a terminal defined
    enum Token {
        // Str => Token::Str(<String>),

        "true" => Token::Bool(true),
        "false" => Token::Bool(false),

        EOF => Token::EOF,
    }
}


// TODO: rename Term
pub Term: Token = {

    <b:Bool> EOF => b,

    EOF => Token::EOF,

    // <n:Num> => Token::Int(n),
    // "(" <t:Term> ")" => t,
};


Bool: Token = {
    "true" => Token::Bool(true),
    "false" => Token::Bool(false),
};


// Num: FieldElement = <integer_str_raw:r"[0-9]+"> =>? {
//     // Underscores needs to be stripped out before the literal can be converted to a `FieldElement.
//     let integer_str = integer_str_raw.replace('_', "");

//     match FieldElement::try_from_str(&integer_str) {
//         None => {
//             let error = vec![LexerErrorKind::InvalidIntegerLiteral {
//                 // TODO: fix span?
//                 span: Span::empty(0), // inclusive(start, end),
//                 found: integer_str,
//             }];

//             // TODO: error recovery
//             // errors.push(ParseError::User { error });
//             Err(ParseError::User { error })

//         }
//         Some(integer) => Ok(integer),
//     }
// };

